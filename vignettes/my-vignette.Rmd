---
title: "Boosted HP Filter"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```




```{r setup}
library(bHP)
```

## HP filter

Given time series data $(x_{t})_{t=1}^n$
the HP method decomposes the series into
two additive components --- a trend component $f_{t}$
and a residual or cyclical component $c_{t}$, estimated as
\[
(\hat{f}_{t}^{HP} )
 =\arg\min_{ (f_{t} )}  \{ \sum_{t=1}^{n} (x_{t}-f_{t} )^{2}
 +\lambda\sum_{t=2}^{n} (\Delta^ 2 f_{t}  )^{2} \},
\]
 and
\[
(\hat{c}_{t}^{HP} )=( x_t-\hat{f}_{t}^{HP}) 
\]
 where $\Delta f_{t}=f_{t}-f_{t-1}$,
and $\Delta^2 f_{t}= \Delta f_{t}- \Delta f_{t-1} = f_{t}- 2 f_{t-1} + f_{t-2}$,
and $\lambda\geq 0$
is a tuning parameter that controls the extent of the penalty.




## Boosted HP filter


In the HP case, if $D'$ is the rectangular $\left(n-2\right)\times n$ matrix
with second differencing vector $d=\begin{pmatrix}1 & -2 & 1\end{pmatrix}'$ along
the leading tri-diagonals and  $I_{n}$ is the $n\times n$ identity
matrix, the explicit form of the trend solution is
\begin{equation} \label{tt1}
\widehat{f}^{\mathrm{HP}}=Sx,
\end{equation}
where $S=\left(I_n+\lambda DD'\right)^{-1}$ is a deterministic operator and $x=(x_1,...,x_n)'$ is the sample data.
The smoothed component $\widehat{f}^{\mathrm{HP}}$ is interpreted as the estimated 
trend and 
\[
\widehat{c}^{\mathrm{HP}}=x-\widehat{f}^{\mathrm{HP}}=\left(I_{n}-S\right)x
\]
as the estimated cyclical or stationary component. 


The problem of consistent HP filter estimation of the trend then amounts to whether as $n \to \infty$ we have 
$ \frac{\widehat{f}_{\left\lfloor nr\right\rfloor }^{\mathrm{HP}}}{\sqrt{n}} \rightsquigarrow B(r)$, 
in which case the filter asymptotically captures the underlying stochastic process trend in $x_t$. PJ show that this reproduction of the asymptotic form of the trend holds only under special restrictions on the smoothing parameter $\lambda$ that ensure it does not diverge too quickly. In particular, if  $\lambda = O(n^4)$ or greater as $n \to \infty$, then the HP filter trend 
$ \widehat{f}_{\left\lfloor nr\right\rfloor }^{\mathrm{HP}}$
 is inconsistent. In such cases, 
$\frac{\widehat{f}_{\left\lfloor nr\right\rfloor }^{\mathrm{HP}}}{\sqrt{n}} \rightsquigarrow f^{\mathrm{HP}}\left(r\right)$ 
where $f^{\mathrm{HP}}\left(r\right)$ is a smooth stochastic process different from $B(r)$, which implies that the cyclical component $\widehat{c}^{\mathrm{HP}}=x-\widehat{f}^{\mathrm{HP}}$ inevitably inherits elements of the stochastic trend even in the limit. Similar issues arise in the case of time series with stochastic trends coupled with deterministic drift or deterministic drift with breaks (see PJ for details). In all these cases, the HP filter fails to recover the underlying trend in $x_t$ asymptotically. The limit theory therefore confirms much informal commentary in the literature concerning the shortcomings of the HP filter as a suitable trend determination mechanism for economic data.     

We propose an easy remedy to establish consistent estimation of stochastic process and deterministic trends in the data. If the cyclical component $\widehat{c}_{t}^{\mathrm{HP}}$ still exhibits
trending behavior after HP filtering, we continue to apply the HP filter to
$\widehat{c}^{\mathrm{HP}}$ to remove the leftover trend residual. After a second fitting, the cyclical component can be written as
\[
\widehat{c}^{\left(2\right)}=\left(I_{n}-S\right)\widehat{c}^{\mathrm{HP}}=\left(I_{n}-S\right)^{2}x,
\]
where the superscript ``$\left(2\right)$'' indicates that the HP
filter is fitted twice. The corresponding trend component becomes
\[
\widehat{f}^{\left(2\right)}=x-\widehat{c}^{\left(2\right)}=\left(I_{n}-\left(I_{n}-S\right)^{2}\right)x.
\]
If $\widehat{c}^{\left(2\right)}$ continues to exhibit trend behavior, the filtering process may be continued for a third or further time. 
After $m$ repeated applications of the filter, the cyclical and trend component are 
\[
	\widehat{c}^{\left(m\right)}  =  \left(I_{n}-S\right)\widehat{c}^{\left(m-1\right)}=\left(I_{n}-S\right)^{m}x \\
	\widehat{f}^{\left(m\right)}  =  x-\widehat{c}^{\left(m\right)}=B_{m}x, 
\]
where $B_{m}=I_{n}-\left(I_{n}-S\right)^{m}.$ We call
this iterated process the \emph{boosted HP filter} or bHP in view of its similarity to $L_{2}$-boosting in terms of  
numerical implementation.



## Examples

```{r, eval=FALSE}
lam <- 100 # tuning parameter for the annaul data

data(IRE) # laod the data 'IRE'

# raw HP filter
bx_HP <- BoostedHP(IRE, lambda = lam, iter= FALSE)

# by BIC
bx_BIC <- BoostedHP(IRE, lambda = lam, iter= TRUE, test_type = "BIC")

# by ADF
bx_ADF <- BoostedHP(IRE, lambda = lam, iter= TRUE, test_type = "adf")

# by none test type
# Iterated HP filter until Max_Iter and keep the path of BIC.

bx_none <- BoostedHP(IRE, lambda = lam, iter= TRUE, test_type = "none")

#-------- plot -----------

?plot.bHP

#--------- start to plot the content of bHP -----------------

#--------- for dynamic style (default)--------
plot(bx_ADF)

plot(bx_ADF, iteration_location = "upright") # change the location of text

plot(bx_ADF, iteration_location = c(30,12)) # assign the location of text by x-y co-ordinates

plot(bx_BIC, interval_t = 0.8 ) # change the time interval of animation

plot(bx_none, cex_legend = 2, cex_text = 3) # change the magnification of legend and text

# change the color
plot(bx_ADF,main = "dynamic graph with new color",col_raw = "#685F74", col_trend_h = "#39A1A8", col_trend_f = "#DD4B4F", col_pvalue_BIC = "#E96145")

plot(bx_ADF,main = "dynamic graph with new trancparency setting",raw_alpha = 200, trend_h_alpha = 55, trend_f_alpha = 250, pvalue_BIC_alpha = 250)

plot(bx_HP)
# none-iter' bHP doesn't have dynamic picture: returning NA

#--------- for JS style ----------

plot(bx_ADF,plot_type = "JS")

# change the color
plot(bx_ADF,plot_type = "JS",main = "Js graph with new color", col_raw = "#685F74", col_trend_f = "#DD4B4F", col_pvalue_BIC = "#39A1A8")

plot(bx_BIC,plot_type = "JS")

plot(bx_none,plot_type = "JS")

plot(bx_HP,plot_type = "JS")

#--------- for static style ----------

plot(bx_ADF,plot_type = "static",cex_legend = 0.7, cex_text = 0.8 )

plot(bx_HP,plot_type = "static")

plot(bx_BIC,plot_type = "static",cex_legend = 0.7, cex_text = 0.8 )

plot(bx_none,plot_type = "static",cex_legend = 0.8, cex_text = 0.8 )

#----------- print -------------------------------

?print.bHP

#--------- start to print the content of bHP -----------------
print(bx_ADF)

print(bx_ADF, Head = F, Tail = T, trend_hist = F)

print(bx_ADF, Head = T, Tail = T, trend_hist = F)

print(bx_ADF, Head = F, Tail = F, trend_hist = F)

print(bx_BIC, Head = F, Tail = F, trend_hist = T, select_trend_hist = 1:bx_BIC$iter_num)

print(bx_BIC, Head = F, Tail = F, trend_hist = T,  select_trend_hist = c(1,3,5))

# when the trend_hist is FALSE, select_trend_hist is invalid
print(bx_BIC, Head = F, Tail = F, trend_hist = F, select_trend_hist = c(1,3,5))

print(bx_BIC, Head = F, Tail = T, trend_hist = F, print_type = "latex")

print(bx_BIC, Head = F, Tail = T, trend_hist = F, print_type = "html")

# show the generic print function output
print(bx_ADF, type = "generic default")



#------------------ summary -----------------

?summary.bHP

summary(bx_ADF)
summary(bx_BIC)
summary(bx_none)
summary(bx_HP)

#------------------ predict -----------------

?predict.bHP

predict(bx_HP) #Iterated number of HP filter: 1

predict(bx_ADF) #Iterated number of HP filter: 19

predict(bx_BIC) #Iterated number of HP filter: 5

predict(bx_none) #Iterated number of HP filter: 99


#------------------ residuals -----------------

?residuals.bHP

residuals(bx_HP) #Iterated number of HP filter: 1

residuals(bx_ADF) #Iterated number of HP filter: 19

#------------------ BIC -------------------------

?BIC.bHP

BIC(bx_BIC)

#Retrun the value path of BIC.
#Iterated number of HP filter: 5
#Keep the path of BIC till iterated 6 times to show the tuning point.
#[1] 1.586255 1.366335 1.293931 1.264323 1.254397 1.254620

BIC(bx_none)

#Retrun the BIC path of none.
#Iterated number of HP filter: 99
#Keep the path of BIC till iterated 100 times to show the tuning point.
#[1] 1.586255 1.366335 1.293931 1.264323 1.254397 1.254620 1.260345 1.269139 1.279670 1.291179
#[11] 1.303223 ...


### If the test type is not "adf", Pvalue.bHP will return error

# raw HP filter
BIC(bx_HP)

# Error in BIC.bHP(bx_HP) :
# The stationary test type is none-iter, not BIC or none.


# by ADF
BIC(bx_ADF)

#Error in BIC.bHP(bx_ADF) :
#The stationary test type is adf, not BIC or none.

```




